{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>{% if lesson %}{{ lesson.title }}{% else %}Audio Player{% endif %} - LeQ</title>
    
    <!-- YouTube IFrame API (for YouTube audio support) -->
    <script src="https://www.youtube.com/iframe_api"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg-dark: #121212;
            --bg-card: #1E1E1E;
            --text-main: #FFFFFF;
            --text-sub: #A0A0A0;
            --accent: #A855F7; /* Purple */
            --accent-glow: rgba(168, 85, 247, 0.4);
            --progress-bg: #333333;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-dark);
            color: var(--text-main);
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        /* Gradient Background Bloom */
        .bg-bloom {
            position: absolute;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at 50% -20%, #2a2a2a, var(--bg-dark) 60%);
            z-index: -1;
            animation: bloomPulse 10s ease-in-out infinite alternate;
        }

        @keyframes bloomPulse {
            0% { opacity: 0.8; transform: scale(1); }
            100% { opacity: 1; transform: scale(1.05); }
        }

        .player-container {
            width: 100%;
            max-width: 500px;
            height: 100vh;
            display: flex;
            flex-direction: column;
            padding: 20px;
            position: relative;
            margin: 0 auto;
            justify-content: space-between;
        }

        /* --- Header --- */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            margin-bottom: auto; /* Push down content */
        }

        /* ... icon-btn styles ... */
        .icon-btn {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: var(--text-main);
            width: 44px;
            height: 44px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background 0.2s;
        }

        .icon-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .icon-btn svg {
            width: 24px;
            height: 24px;
        }

        /* --- Vinyl Section --- */
        .vinyl-wrapper {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            width: 100%;
            padding: 20px 0;
        }
        
        /* Interactive scaling container for Vinyl + Arm */
        .vinyl-group {
            position: relative;
            width: min(70vw, 300px);
            height: min(70vw, 300px);
            max-width: 300px;
            max-height: 300px;
        }

        .vinyl-record {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: 
                radial-gradient(circle, #111 0%, #111 25%, #222 26%, #111 27%, #111 35%, #222 36%, #111 37%, #111 50%, #222 51%, #111 52%, #000 70%);
            box-shadow: 
                0 10px 40px rgba(0,0,0,0.6),
                inset 0 0 0 5px #333; /* Outer rim */
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: spin 8s linear infinite;
            animation-play-state: paused;
        }

        .vinyl-record::after {
            /* Shine effect */
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, transparent 40%, transparent 60%, rgba(255,255,255,0.05) 100%);
            pointer-events: none;
        }
        
        /* Album Art in Center */
        .album-art {
            width: 45%;
            height: 45%;
            border-radius: 50%;
            background-color: #333;
            background-size: cover;
            background-position: center;
            position: relative;
            z-index: 2;
            box-shadow: 0 0 0 4px #1a1a1a;
        }

        /* Tone Arm (Stylized Needle) */
        .tone-arm {
            position: absolute;
            top: -10%;
            right: -10%;
            width: 35%;
            height: 50%;
            transform-origin: top right;
            transform: rotate(-30deg);
            transition: transform 0.8s ease-in-out;
            z-index: 5;
            pointer-events: none;
            filter: drop-shadow(4px 4px 8px rgba(0,0,0,0.5));
        }

        /* SVG Tone Arm Drawing */
        .tone-arm svg {
            width: 100%;
            height: 100%;
            fill: #d1d5db;
        }

        .playing .tone-arm {
            transform: rotate(10deg); /* Moves needle onto record */
        }
        
        .playing .vinyl-record {
            animation-play-state: running;
        }

        @keyframes spin {
            100% { transform: rotate(360deg); }
        }

        /* --- Track Info --- */
        .track-info {
            text-align: center;
            margin-bottom: 10px;
        }

        .track-title {
            font-size: 22px;
            font-weight: 700;
            margin-bottom: 6px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            padding: 0 20px;
        }

        .track-artist {
            font-size: 14px;
            color: var(--text-sub);
            font-weight: 500;
            padding: 0 20px;
        }

        /* --- Progress Arc --- */
        .progress-container {
            position: relative;
            height: 70px;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
        }

        .progress-svg {
            width: 100%;
            height: 100%;
            overflow: visible;
        }

        .progress-bg-path {
            fill: none;
            stroke: var(--progress-bg);
            stroke-width: 4;
            stroke-linecap: round;
        }

        .progress-active-path {
            fill: none;
            stroke: var(--accent);
            stroke-width: 4;
            stroke-linecap: round;
            transition: stroke-dashoffset 0.1s linear;
            cursor: pointer;
        }

        /* Time Labels inside the arc curve area */
        .time-label {
            position: absolute;
            font-size: 12px;
            color: var(--text-sub);
            font-weight: 500;
        }
        .time-current { left: 20px; bottom: 30px; }
        .time-total { right: 20px; bottom: 30px; }


        /* --- Controls --- */
        .controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 40px;
            padding: 0 10px;
            margin-bottom: 20px;
        }

        .ctrl-btn {
            background: transparent;
            border: none;
            color: var(--text-main);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275), color 0.2s ease;
        }

        .ctrl-btn:hover {
            color: white;
            transform: scale(1.1);
        }

        .ctrl-btn:active {
            transform: scale(0.95);
        }

        .ctrl-btn-sm svg { width: 24px; height: 24px; color: var(--text-sub); }
        .ctrl-btn-md svg { width: 32px; height: 32px; }

        .play-btn {
            width: 72px;
            height: 72px;
            background: var(--accent);
            border-radius: 50%;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .play-btn svg {
            width: 32px;
            height: 32px;
            fill: white;
            transition: transform 0.2s ease;
        }
        
        .play-btn:hover {
            transform: scale(1.1);
            background: #9333ea;
        }
        
        .play-btn:active {
            transform: scale(0.95);
        }

        /* --- Bottom Aux Controls --- */
        .aux-controls {
            position: absolute;
            bottom: 30px;
            right: 30px;
        }
        .aux-btn {
            width: 50px;
            height: 50px;
            background: #f1f5f9;
            border-radius: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            color: black;
            cursor: pointer;
        }

        /* Loader */
        .loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 20;
            pointer-events: none;
        }
        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255,255,255,0.1);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spinLoader 1s linear infinite;
        }
        @keyframes spinLoader { to { transform: rotate(360deg); } }
        .hidden { display: none; }

        /* Menu Modal */
        .menu-modal {
            position: fixed;
            bottom: 0px;
            left: 0;
            width: 100%;
            background: #222;
            border-radius: 20px 20px 0 0;
            padding: 24px;
            transform: translateY(100%);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 100;
        }
        .menu-modal.active {
            transform: translateY(0);
        }
        .menu-option {
            padding: 16px;
            border-bottom: 1px solid #333;
            color: #fff;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }
        .menu-option:last-child { border-bottom: none; }
        .menu-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.5);
            z-index: 99;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        .menu-overlay.active { opacity: 1; pointer-events: auto; }

    </style>
</head>
<body>

    <div class="bg-bloom"></div>

    <div class="player-container {% if is_playing %}playing{% endif %}" id="playerContainer">
        
        <!-- Header -->
        <div class="header">
            <button class="icon-btn" onclick="goBack()">
                <i data-lucide="arrow-left"></i>
            </button>
            <button class="icon-btn" id="menuBtn">
                <i data-lucide="more-horizontal"></i>
            </button>
        </div>

        <!-- Vinyl -->
        <div class="vinyl-wrapper">
            <div class="vinyl-group">
                <div class="vinyl-record" id="vinylRecord">
                    <div class="album-art" style="background-image: url('{% if lesson.thumbnail %}{{ lesson.thumbnail.url }}{% else %}https://images.unsplash.com/photo-1470225620780-dba8ba36b745?q=80&w=300&auto=format&fit=crop{% endif %}');"></div>
                </div>
                
                <!-- Tone Arm SVG -->
                <div class="tone-arm" id="toneArm">
                    <svg viewBox="0 0 100 240" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M50 10 C 50 10, 50 0, 60 0 L 80 0 C 90 0, 90 10, 90 10 L 90 40 C 90 50, 80 50, 80 50 L 60 50 C 50 50, 50 40, 50 40 Z" fill="#4b5563"/>
                        <rect x="65" y="50" width="10" height="100" fill="#6b7280"/>
                        <rect x="60" y="150" width="20" height="40" rx="4" fill="#374151"/>
                        <path d="M70 190 L 40 220 L 50 230 L 80 200 Z" fill="#9ca3af"/>
                        <circle cx="45" cy="225" r="3" fill="#ef4444"/>
                    </svg>
                </div>
            </div>
        </div>

        <!-- Track Info -->
        <div class="track-info">
            <div class="track-title">{% if lesson %}{{ lesson.title }}{% else %}Loading...{% endif %}</div>
            <div class="track-artist">{% if course %}{{ course.title }}{% else %}Audio Lesson{% endif %}</div>
        </div>

        <!-- Arc Progress Bar -->
        <div class="progress-container">
            <span class="time-label time-current" id="currentTime">0:00</span>
            
            <!-- SVG Arc -->
            <svg class="progress-svg" viewBox="0 0 300 60" preserveAspectRatio="none">
                <!-- Helper definition for the curve path -->
                <defs>
                    <!-- A quadratic bezier curve for a gentle smile shape -->
                    <!-- M 10,30 Q 150,80 290,30 -->
                    <!-- Adjusted coordinates to fit container properly -->
                    <path id="progressCurve" d="M 20,20 Q 150,70 280,20" />
                </defs>
                
                <!-- Background Rail -->
                <path d="M 20,20 Q 150,70 280,20" class="progress-bg-path" />
                
                <!-- Active Progress -->
                <!-- stroke-dasharray will be set via JS based on path length -->
                <path d="M 20,20 Q 150,70 280,20" class="progress-active-path" id="progressPath" />
                
                <!-- Interaction Hit Area (invisible thicker line) -->
                <path d="M 20,20 Q 150,70 280,20" stroke="transparent" stroke-width="20" fill="none" style="cursor: pointer;" id="progressHitArea"/>
            </svg>

            <span class="time-label time-total" id="duration">0:00</span>
        </div>

        <!-- Controls -->
        <div class="controls" style="justify-content: center; gap: 40px;">
            <button class="ctrl-btn ctrl-btn-md" id="prevBtn">
                <i data-lucide="skip-back"></i>
            </button>
            
            <button class="play-btn" id="playPauseBtn">
                <i data-lucide="play" fill="white"></i>
            </button>
            
            <button class="ctrl-btn ctrl-btn-md" id="nextBtn">
                <i data-lucide="skip-forward"></i>
            </button>
        </div>
        <!-- Magic button removed -->

    </div>

    <!-- Menus / Overlays -->
    <div class="menu-overlay" id="menuOverlay"></div>
    <div class="menu-modal" id="menuModal">
        <div class="menu-option" data-speed="1.0">
            <span>Normal Speed (1.0x)</span>
            <i data-lucide="check" class="speed-check hidden" id="check-1.0"></i>
        </div>
        <div class="menu-option" data-speed="1.25">
            <span>Speed 1.25x</span>
            <i data-lucide="check" class="speed-check hidden" id="check-1.25"></i>
        </div>
        <div class="menu-option" data-speed="1.5">
            <span>Speed 1.5x</span>
            <i data-lucide="check" class="speed-check hidden" id="check-1.5"></i>
        </div>
        <div class="menu-option" data-speed="2.0">
            <span>Speed 2.0x</span>
            <i data-lucide="check" class="speed-check hidden" id="check-2.0"></i>
        </div>
    </div>

    <!-- Loader -->
    <div class="loader hidden" id="loader">
        <div class="spinner"></div>
    </div>
    
    <!-- Error/Info Message -->
    <div id="infoMessage" style="position: fixed; bottom: 80px; left: 50%; transform: translateX(-50%); background: rgba(30, 30, 30, 0.95); color: white; padding: 12px 24px; border-radius: 8px; font-size: 14px; display: none; z-index: 1000; max-width: 90%; text-align: center; box-shadow: 0 4px 12px rgba(0,0,0,0.3);"></div>

    <!-- Hidden Audio Element -->
    <audio id="audioPlayer" preload="metadata"></audio>
    
    <!-- Hidden YouTube Player Container (for YouTube audio) -->
    <div id="youtubePlayerContainer" style="position: absolute; left: -9999px; width: 100px; height: 100px; opacity: 0; pointer-events: none;">
        <div id="youtubePlayer"></div>
    </div>

    <script>
        lucide.createIcons();

        // --- Logic ---
        const audio = document.getElementById('audioPlayer');
        const playPauseBtn = document.getElementById('playPauseBtn');
        const vinylRecord = document.getElementById('vinylRecord');
        const playerContainer = document.getElementById('playerContainer');
        const progressPath = document.getElementById('progressPath');
        const progressHitArea = document.getElementById('progressHitArea');
        const currentTimeEl = document.getElementById('currentTime');
        const durationEl = document.getElementById('duration');
        const loader = document.getElementById('loader');
        
        // YouTube player variables
        let youtubePlayer = null;
        let youtubeUpdateInterval = null;
        let isUsingYouTube = false;
        let isAdPlaying = false;
        let adCheckInterval = null;
        let playerReady = false;
        let hasEmbeddingError = false;
        let retryCount = 0;
        const maxRetries = 2;
        
        const menuBtn = document.getElementById('menuBtn');
        const menuModal = document.getElementById('menuModal');
        const menuOverlay = document.getElementById('menuOverlay');
        const speedOptions = document.querySelectorAll('.menu-option');
        const infoMessage = document.getElementById('infoMessage');
        // Disable native browser alert popups on this page
        window.alert = function() {};

        // Restore or default playback speed (persisted per user in localStorage)
        let initialSpeed = parseFloat(localStorage.getItem('audioPlayerSpeed')) || 1.0;
        
        // Helper function to show info messages
        // Suppresses specific YouTube loading/ready messages unless `options.force` is true.
        function showInfo(message, duration = 3000, options = {}) {
            try {
                const raw = (message || '').toString();
                const plain = raw.replace(/<[^>]*>/g, '').trim();
                const lower = plain.toLowerCase();

                // Suppress non-actionable YouTube status messages requested to hide
                if (!options.force) {
                    if (/^loading youtube (audio|content)/i.test(lower) || /youtube audio ready/i.test(lower) || /buffering/i.test(lower)) {
                        console.debug('[AudioPlayer] suppressed info message:', plain);
                        return;
                    }
                }
            } catch (e) {
                // If anything goes wrong with message processing, fall back to showing it
            }

            infoMessage.innerHTML = message; // Use innerHTML to support HTML links
            infoMessage.style.display = 'block';
            if (duration > 0) {
                setTimeout(() => {
                    infoMessage.style.display = 'none';
                }, duration);
            }
        }

        // Audio Source Configuration
        const audioUrl = "{{ audio_url|default:''|escapejs }}";
        const hasYouTubeAudio = {% if has_youtube_audio %}true{% else %}false{% endif %};
        const youtubeVideoId = "{{ youtube_video_id|default:''|escapejs }}";

        if (hasYouTubeAudio && youtubeVideoId) {
            console.log('[AudioPlayer] Using YouTube audio:', youtubeVideoId);
            isUsingYouTube = true;
            loader.classList.remove('hidden');
            showInfo('Loading YouTube audio...', 0);

            // Initialize YouTube API player when available
            if (typeof YT !== 'undefined' && YT.Player) {
                console.log('[AudioPlayer] YouTube API already loaded, initializing player');
                initYouTubeAudioPlayer();
            } else {
                console.log('[AudioPlayer] Waiting for YouTube API to load...');
                window.onYouTubeIframeAPIReady = function() {
                    console.log('[AudioPlayer] YouTube API loaded, initializing player');
                    initYouTubeAudioPlayer();
                };
            }
        } else if (audioUrl) {
            console.log('[AudioPlayer] Using regular audio file:', audioUrl);
            audio.src = audioUrl;
            audio.addEventListener('loadedmetadata', () => {
                showInfo('Audio loaded successfully', 2000);
            });
        } else {
            console.warn('[AudioPlayer] No audio source found');
            console.log('[AudioPlayer] hasYouTubeAudio:', hasYouTubeAudio);
            console.log('[AudioPlayer] youtubeVideoId:', youtubeVideoId);
            console.log('[AudioPlayer] audioUrl:', audioUrl);
            showInfo('No audio source available', 5000);
        }

        // --- SVG Arc Progress Setup ---
        // Calculate path length for dasharray
        const pathLength = progressPath.getTotalLength();
        progressPath.style.strokeDasharray = pathLength;
        progressPath.style.strokeDashoffset = pathLength; // Start empty

        function updateProgressUI(percent) {
            const offset = pathLength - (pathLength * percent / 100);
            progressPath.style.strokeDashoffset = offset;
        }
        
        // --- YouTube Audio Player Initialization ---
        function initYouTubeAudioPlayer() {
            console.log('[AudioPlayer] initYouTubeAudioPlayer called');
            console.log('[AudioPlayer] youtubeVideoId:', youtubeVideoId);
            loader.classList.remove('hidden');
            
            try {
                youtubePlayer = new YT.Player('youtubePlayer', {
                    height: '1',
                    width: '1',
                    videoId: youtubeVideoId,
                    playerVars: {
                        'autoplay': 0,
                        'controls': 0,
                        'disablekb': 1,
                        'fs': 0,
                        'modestbranding': 1,
                        'playsinline': 1,
                        'rel': 0,
                        'iv_load_policy': 3
                    },
                    events: {
                        'onReady': onYouTubePlayerReady,
                        'onStateChange': onYouTubePlayerStateChange,
                        'onError': onYouTubePlayerError
                    }
                });
                console.log('[AudioPlayer] YouTube Player created successfully');
            } catch (error) {
                console.error('[AudioPlayer] Error creating YouTube player:', error);
                loader.classList.add('hidden');
                showInfo('Failed to initialize YouTube player', 5000);
            }
        }
        
        // YouTube Player Event Handlers
        function onYouTubePlayerReady(event) {
            console.log('[AudioPlayer] YouTube player ready');
            playerReady = true;
            loader.classList.add('hidden');
            // Apply initial playback speed for YouTube player
            try {
                if (youtubePlayer && typeof youtubePlayer.setPlaybackRate === 'function') {
                    youtubePlayer.setPlaybackRate(initialSpeed);
                }
            } catch (e) {
                console.warn('[AudioPlayer] Could not set initial YouTube playback rate', e);
            }
            
            try {
                // Start ad detection
                startAdDetection();
                
                // Set duration (might be 0 initially if ads are loading)
                setTimeout(() => {
                    const duration = youtubePlayer.getDuration();
                    if (duration && duration > 0) {
                        console.log('[AudioPlayer] Video duration:', duration);
                        durationEl.textContent = formatTime(duration);
                        showInfo('YouTube audio ready', 2000);
                    } else {
                        showInfo('Loading YouTube content...', 0);
                    }
                }, 500);
                
                // Start update interval
                youtubeUpdateInterval = setInterval(() => {
                    if (youtubePlayer && !isAdPlaying) {
                        const state = youtubePlayer.getPlayerState();
                        if (state === YT.PlayerState.PLAYING) {
                            const currentTime = youtubePlayer.getCurrentTime();
                            const duration = youtubePlayer.getDuration();
                            
                            if (duration > 0) {
                                const percent = (currentTime / duration) * 100;
                                updateProgressUI(percent);
                                currentTimeEl.textContent = formatTime(currentTime);
                            }
                        }
                    }
                }, 100);
                
                console.log('[AudioPlayer] YouTube player initialization complete');
            } catch (error) {
                console.error('[AudioPlayer] Error in onYouTubePlayerReady:', error);
            }
        }
        
        // Ad Detection and Handling
        function startAdDetection() {
            if (adCheckInterval) clearInterval(adCheckInterval);
            
            adCheckInterval = setInterval(() => {
                if (!youtubePlayer || !playerReady) return;
                
                try {
                    // Check if we can get video data - if not, likely an ad is playing
                    const duration = youtubePlayer.getDuration();
                    const currentTime = youtubePlayer.getCurrentTime();
                    const videoLoadedFraction = youtubePlayer.getVideoLoadedFraction();
                    
                    // If duration is 0 or very short, and something is playing, it's likely an ad
                    const wasAdPlaying = isAdPlaying;
                    isAdPlaying = (duration === 0 && youtubePlayer.getPlayerState() !== YT.PlayerState.UNSTARTED) || 
                                 (duration > 0 && duration < 10 && videoLoadedFraction === 0);
                    
                    if (isAdPlaying && !wasAdPlaying) {
                        console.log('[AudioPlayer] Ad detected, pausing UI updates');
                        showInfo('Ad playing - audio will start after ad', 0);
                        updatePlayButtonState(false);
                    } else if (!isAdPlaying && wasAdPlaying) {
                        console.log('[AudioPlayer] Ad finished, resuming normal playback');
                        const newDuration = youtubePlayer.getDuration();
                        if (newDuration > 0) {
                            durationEl.textContent = formatTime(newDuration);
                            showInfo('YouTube audio ready', 2000);
                        }
                    }
                } catch (error) {
                    // Ignore errors during ad detection
                }
            }, 500);
        }
        
        function onYouTubePlayerStateChange(event) {
            console.log('[AudioPlayer] YouTube state changed:', event.data, isAdPlaying ? '(Ad playing)' : '(Content)');
            
            // If we have embedding error, ignore state changes
            if (hasEmbeddingError) {
                console.log('[AudioPlayer] Ignoring state change due to embedding restriction');
                return;
            }
            
            // Handle different states with ad awareness
            if (event.data === YT.PlayerState.PLAYING) {
                retryCount = 0; // Reset retry count on successful play
                if (!isAdPlaying) {
                    playerContainer.classList.add('playing');
                    updatePlayButtonState(true);
                    loader.classList.add('hidden');
                } else {
                    // Ad is playing - show different UI state
                    updatePlayButtonState(false);
                    showInfo('Ad playing - please wait...', 0);
                }
            } else if (event.data === YT.PlayerState.PAUSED) {
                if (!isAdPlaying) {
                    playerContainer.classList.remove('playing');
                    updatePlayButtonState(false);
                }
            } else if (event.data === YT.PlayerState.BUFFERING) {
                loader.classList.remove('hidden');
                if (!isAdPlaying) {
                    showInfo('Buffering...', 0);
                }
            } else if (event.data === YT.PlayerState.ENDED) {
                playerContainer.classList.remove('playing');
                updatePlayButtonState(false);
                if (adCheckInterval) {
                    clearInterval(adCheckInterval);
                }
            } else if (event.data === YT.PlayerState.UNSTARTED) {
                // Video is loading - but check if we're in a retry loop
                if (retryCount > maxRetries) {
                    console.warn('[AudioPlayer] Too many retries, stopping attempts');
                    hasEmbeddingError = true;
                    const videoUrl = `https://www.youtube.com/watch?v=${youtubeVideoId}`;
                    showInfo(
                        `Unable to load video. <a href="${videoUrl}" target="_blank" style="color: #4CAF50; text-decoration: underline;">Try opening in YouTube</a>`,
                        0
                    );
                    return;
                }
                showInfo('Loading YouTube content...', 0);
            }
        }
        
        function onYouTubePlayerError(event) {
            console.error('[AudioPlayer] YouTube player error:', event.data);
            const errorMessages = {
                2: 'Invalid video ID',
                5: 'HTML5 player error',
                100: 'Video not found or private',
                101: 'Video not allowed to be played in embedded players',
                150: 'Video not allowed to be played in embedded players'
            };
            const errorMsg = errorMessages[event.data] || 'Unknown error';
            console.error('[AudioPlayer] Error details:', errorMsg);
            
            // Handle embedding restriction errors (101, 150)
            if (event.data === 101 || event.data === 150) {
                hasEmbeddingError = true;
                
                // Stop all intervals and detection
                if (youtubeUpdateInterval) {
                    clearInterval(youtubeUpdateInterval);
                    youtubeUpdateInterval = null;
                }
                if (adCheckInterval) {
                    clearInterval(adCheckInterval);
                    adCheckInterval = null;
                }
                
                loader.classList.add('hidden');
                playerContainer.classList.remove('playing');
                updatePlayButtonState(false);
                
                // Show helpful message with YouTube link
                const videoUrl = `https://www.youtube.com/watch?v=${youtubeVideoId}`;
                showInfo(
                    `This video cannot be embedded. <a href="${videoUrl}" target="_blank" style="color: #4CAF50; text-decoration: underline;">Open in YouTube</a>`,
                    0
                );
                
                return; // Stop processing
            }
            
            // For other errors, show generic message
            loader.classList.add('hidden');
            showInfo('YouTube Error: ' + errorMsg, 8000);
        }

        // --- Event Listeners ---
        
        playPauseBtn.addEventListener('click', togglePlay);
        
        // Regular audio element events (only for non-YouTube)
        if (!isUsingYouTube) {
            audio.addEventListener('play', () => {
                playerContainer.classList.add('playing');
                updatePlayButtonState(true);
            });

            audio.addEventListener('pause', () => {
                playerContainer.classList.remove('playing');
                updatePlayButtonState(false);
            });

            audio.addEventListener('timeupdate', () => {
                if (!audio.duration) return;
                const percent = (audio.currentTime / audio.duration) * 100;
                updateProgressUI(percent);
                currentTimeEl.textContent = formatTime(audio.currentTime);
            });

            audio.addEventListener('loadedmetadata', () => {
                durationEl.textContent = formatTime(audio.duration);
            });
            
            audio.addEventListener('waiting', () => loader.classList.remove('hidden'));
            audio.addEventListener('playing', () => loader.classList.add('hidden'));
        }

        // Seek Interaction
        progressHitArea.addEventListener('click', (e) => {
            if (isUsingYouTube && isAdPlaying) {
                showInfo('Cannot seek during ads', 2000);
                return;
            }
            
            const duration = isUsingYouTube ? youtubePlayer.getDuration() : audio.duration;
            if (!duration) return;
            
            // Calculate click position relative to the SVG width
            const rect = progressHitArea.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const percent = Math.max(0, Math.min(1, x / rect.width));
            
            if (isUsingYouTube) {
                youtubePlayer.seekTo(percent * duration, true);
            } else {
                audio.currentTime = percent * duration;
            }
        });

        // Controls
        document.getElementById('prevBtn').addEventListener('click', () => {
            if (isUsingYouTube) {
                if (isAdPlaying) {
                    showInfo('Cannot seek during ads', 2000);
                    return;
                }
                const currentTime = youtubePlayer.getCurrentTime();
                youtubePlayer.seekTo(Math.max(0, currentTime - 10), true);
            } else {
                audio.currentTime = Math.max(0, audio.currentTime - 10);
            }
        });

        document.getElementById('nextBtn').addEventListener('click', () => {
            if (isUsingYouTube) {
                if (isAdPlaying) {
                    showInfo('Cannot seek during ads', 2000);
                    return;
                }
                const currentTime = youtubePlayer.getCurrentTime();
                const duration = youtubePlayer.getDuration();
                youtubePlayer.seekTo(Math.min(duration, currentTime + 10), true);
            } else {
                audio.currentTime = Math.min(audio.duration, audio.currentTime + 10);
            }
        });

        // Menu
        // Apply initial speed for non-YouTube audio now. YouTube rate is applied when player is ready.
        if (!isUsingYouTube && typeof audio !== 'undefined') {
            audio.playbackRate = initialSpeed;
        }

        menuBtn.addEventListener('click', () => {
            menuModal.classList.add('active');
            menuOverlay.classList.add('active');
        });

        menuOverlay.addEventListener('click', () => {
            menuModal.classList.remove('active');
            menuOverlay.classList.remove('active');
        });

        speedOptions.forEach(opt => {
            opt.addEventListener('click', () => {
                const speed = parseFloat(opt.dataset.speed);
                
                if (isUsingYouTube && youtubePlayer) {
                    youtubePlayer.setPlaybackRate(speed);
                } else {
                    audio.playbackRate = speed;
                }
                // Persist chosen speed
                try { localStorage.setItem('audioPlayerSpeed', String(speed)); } catch (e) { /* ignore */ }
                
                // Update UI checkmarks
                document.querySelectorAll('.speed-check').forEach(el => el.classList.add('hidden'));
                opt.querySelector('.speed-check').classList.remove('hidden');
                
                // Close menu
                menuModal.classList.remove('active');
                menuOverlay.classList.remove('active');
            });
        });

        // --- Helpers ---

        // --- Volume Restoration ---
        const savedVolume = localStorage.getItem('audioPlayerVolume');
        if (savedVolume !== null && !isUsingYouTube) {
            audio.volume = parseFloat(savedVolume);
        }

        function goBack() {
            // "Permanent fix": Directly navigate to the appropriate parent page
            // If the user is enrolled, go to the learning dashboard for this course.
            // If not (e.g. preview), go to the course detail/marketing page.
            {% if enrollment %}
                window.location.href = "{% url 'courses:course_learn' course.id %}";
            {% else %}
                window.location.href = "{% url 'courses:course_detail' course.slug %}";
            {% endif %}
        }

        function togglePlay() {
            if (isUsingYouTube) {
                if (!youtubePlayer || !playerReady) {
                    console.error('[AudioPlayer] YouTube player not initialized');
                    showInfo('Player not ready yet', 2000);
                    return;
                }
                
                if (hasEmbeddingError) {
                    const videoUrl = `https://www.youtube.com/watch?v=${youtubeVideoId}`;
                    showInfo(
                        `Video restricted. <a href="${videoUrl}" target="_blank" style="color: #4CAF50; text-decoration: underline;">Open in YouTube</a>`,
                        5000
                    );
                    return;
                }
                
                if (isAdPlaying) {
                    showInfo('Please wait for ad to finish', 3000);
                    return;
                }
                
                try {
                    const state = youtubePlayer.getPlayerState();
                    console.log('[AudioPlayer] Current player state:', state);
                    
                    if (state === YT.PlayerState.PLAYING) {
                        console.log('[AudioPlayer] Pausing YouTube video');
                        youtubePlayer.pauseVideo();
                    } else {
                        console.log('[AudioPlayer] Playing YouTube video');
                        retryCount++;
                        youtubePlayer.playVideo();
                    }
                } catch (error) {
                    console.error('[AudioPlayer] Error in togglePlay:', error);
                    showInfo('Playback error occurred', 3000);
                }
            } else {
                if (audio.paused) {
                    audio.play();
                } else {
                    audio.pause();
                }
            }
        }

        // Keyboard Shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT') return;
            switch(e.key.toLowerCase()) {
                case ' ':
                case 'k':
                    e.preventDefault();
                    togglePlay();
                    break;
                case 'arrowleft':
                case 'j':
                    if (isUsingYouTube) {
                        if (isAdPlaying) {
                            showInfo('Cannot seek during ads', 2000);
                            return;
                        }
                        const currentTime = youtubePlayer.getCurrentTime();
                        youtubePlayer.seekTo(Math.max(0, currentTime - 10), true);
                    } else {
                        audio.currentTime = Math.max(0, audio.currentTime - 10);
                    }
                    break;
                case 'arrowright':
                case 'l':
                    if (isUsingYouTube) {
                        if (isAdPlaying) {
                            showInfo('Cannot seek during ads', 2000);
                            return;
                        }
                        const currentTime = youtubePlayer.getCurrentTime();
                        const duration = youtubePlayer.getDuration();
                        youtubePlayer.seekTo(Math.min(duration, currentTime + 10), true);
                    } else {
                        audio.currentTime = Math.min(audio.duration, audio.currentTime + 10);
                    }
                    break;
                case 'arrowup':
                    e.preventDefault();
                    if (!isUsingYouTube) {
                        audio.volume = Math.min(1, audio.volume + 0.1);
                        localStorage.setItem('leq_volume', audio.volume);
                    }
                    break;
                case 'arrowdown':
                    e.preventDefault();
                    if (!isUsingYouTube) {
                        audio.volume = Math.max(0, audio.volume - 0.1);
                        localStorage.setItem('leq_volume', audio.volume);
                    }
                    break;
            }
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (youtubeUpdateInterval) {
                clearInterval(youtubeUpdateInterval);
            }
            if (adCheckInterval) {
                clearInterval(adCheckInterval);
            }
        });

        // Media Session API
        if ('mediaSession' in navigator && !isUsingYouTube) {
            audio.addEventListener('play', () => {
                navigator.mediaSession.playbackState = 'playing';
            });
            audio.addEventListener('pause', () => {
                navigator.mediaSession.playbackState = 'paused';
            });
            
            // metadata updated in loadedmetadata if available, strictly we need song title
            const title = document.querySelector('.track-title').textContent.trim();
            const artist = document.querySelector('.track-artist').textContent.trim();
            const artwork = "{% if lesson.thumbnail %}{{ lesson.thumbnail.url }}{% endif %}";
            
            navigator.mediaSession.metadata = new MediaMetadata({
                title: title,
                artist: artist,
                artwork: artwork ? [{ src: artwork, sizes: '512x512', type: 'image/jpeg' }] : []
            });

            navigator.mediaSession.setActionHandler('play', togglePlay);
            navigator.mediaSession.setActionHandler('pause', togglePlay);
            navigator.mediaSession.setActionHandler('seekbackward', () => { audio.currentTime = Math.max(0, audio.currentTime - 10); });
            navigator.mediaSession.setActionHandler('seekforward', () => { audio.currentTime = Math.min(audio.duration, audio.currentTime + 10); });
        }

        function updatePlayButtonState(isPlaying) {
            const icon = playPauseBtn.querySelector('svg');
            // Remove old icon content
            while (icon.firstChild) {
                icon.removeChild(icon.firstChild);
            }
            
            // Set new icon (Lucide specific attributes handled by replaceWith or reset)
            // Easier way: toggle data-lucide and re-render, 
            // OR manually set innerHTML for SVG path
            
            if (isPlaying) {
                // Pause Icon
                playPauseBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-pause"><rect width="4" height="16" x="6" y="4"/><rect width="4" height="16" x="14" y="4"/></svg>';
            } else {
                // Play Icon
                playPauseBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-play"><polygon points="6 3 20 12 6 21 6 3"/></svg>';
            }
        }

        function formatTime(seconds) {
            const m = Math.floor(seconds / 60);
            const s = Math.floor(seconds % 60);
            return `${m}:${s.toString().padStart(2, '0')}`;
        }

        // Active speed check init - show the saved/default speed
        try {
            speedOptions.forEach(opt => {
                const chk = opt.querySelector('.speed-check');
                if (!chk) return;
                if (parseFloat(opt.dataset.speed) === initialSpeed) {
                    chk.classList.remove('hidden');
                } else {
                    chk.classList.add('hidden');
                }
            });
        } catch (e) {
            const el = document.getElementById('check-1.0');
            if (el) el.classList.remove('hidden');
        }

        // Progress Tracking
        const lessonId = "{% if lesson %}{{ lesson.id }}{% endif %}";
        function updateProgressTracking() {
            if (!lessonId) return;
            
            let watchTime, duration, isPaused, playbackRate;
            
            if (isUsingYouTube) {
                if (!youtubePlayer) return;
                watchTime = Math.floor(youtubePlayer.getCurrentTime());
                duration = Math.floor(youtubePlayer.getDuration());
                isPaused = youtubePlayer.getPlayerState() !== YT.PlayerState.PLAYING;
                playbackRate = youtubePlayer.getPlaybackRate();
            } else {
                if (!audio.currentTime) return;
                watchTime = Math.floor(audio.currentTime);
                duration = Math.floor(audio.duration);
                isPaused = audio.paused;
                playbackRate = audio.playbackRate;
            }
            
            const isCompleted = duration > 0 && watchTime >= duration * 0.9;
            const csrfToken = document.cookie.split('; ').find(row => row.startsWith('csrftoken='))?.split('=')[1];
            
            fetch(`/courses/lessons/${lessonId}/progress/`, {
                method: 'POST',
                headers: { 
                    'Content-Type': 'application/json',
                    'X-CSRFToken': csrfToken
                },
                body: JSON.stringify({ 
                    watchTime, 
                    isCompleted,
                    playerState: isPaused ? 4 : 3,
                    playbackRate: playbackRate
                })
            }).catch(err => console.error(err));
        }

        setInterval(() => {
            if (isUsingYouTube) {
                if (youtubePlayer && youtubePlayer.getPlayerState() === YT.PlayerState.PLAYING) {
                    updateProgressTracking();
                }
            } else {
                if (!audio.paused) updateProgressTracking();
            }
        }, 10000);
        
        window.addEventListener('beforeunload', updateProgressTracking);

    </script>
</body>
</html>
